// Generated protobuf types. Do not edit manually.
// Regenerate with: cargo run -p rocktree-proto --bin generate

#![allow(clippy::doc_markdown)]
#![allow(clippy::must_use_candidate)]

// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkMetadataRequest {
    #[prost(message, optional, tag = "1")]
    pub node_key: ::core::option::Option<NodeKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeDataRequest {
    #[prost(message, optional, tag = "1")]
    pub node_key: ::core::option::Option<NodeKey>,
    #[prost(enumeration = "texture::Format", optional, tag = "2")]
    pub texture_format: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub imagery_epoch: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeKey {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub epoch: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CopyrightRequest {
    #[prost(uint32, optional, tag = "1")]
    pub epoch: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextureDataRequest {
    #[prost(message, optional, tag = "1")]
    pub node_key: ::core::option::Option<NodeKey>,
    #[prost(enumeration = "texture::Format", optional, tag = "2")]
    pub texture_format: ::core::option::Option<i32>,
    #[prost(enumeration = "texture::ViewDirection", optional, tag = "3")]
    pub view_direction: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkMetadata {
    #[prost(message, repeated, tag = "1")]
    pub node_metadata: ::prost::alloc::vec::Vec<NodeMetadata>,
    #[prost(message, optional, tag = "2")]
    pub head_node_key: ::core::option::Option<NodeKey>,
    #[prost(double, repeated, tag = "3")]
    pub head_node_center: ::prost::alloc::vec::Vec<f64>,
    #[prost(float, repeated, tag = "4")]
    pub meters_per_texel: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, optional, tag = "5")]
    pub default_imagery_epoch: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub default_available_texture_formats: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub default_available_view_dependent_textures: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub default_available_view_dependent_texture_formats: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMetadata {
    #[prost(uint32, optional, tag = "1")]
    pub path_and_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub epoch: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub bulk_metadata_epoch: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub oriented_bounding_box: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, optional, tag = "4")]
    pub meters_per_texel: ::core::option::Option<f32>,
    #[prost(double, repeated, tag = "6")]
    pub processing_oriented_bounding_box: ::prost::alloc::vec::Vec<f64>,
    #[prost(uint32, optional, tag = "7")]
    pub imagery_epoch: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub available_texture_formats: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub available_view_dependent_textures: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub available_view_dependent_texture_formats: ::core::option::Option<u32>,
}
/// Nested message and enum types in `NodeMetadata`.
pub mod node_metadata {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Flags {
        Rich3dLeaf = 1,
        Rich3dNodata = 2,
        Leaf = 4,
        Nodata = 8,
        UseImageryEpoch = 16,
    }
    impl Flags {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Rich3dLeaf => "RICH3D_LEAF",
                Self::Rich3dNodata => "RICH3D_NODATA",
                Self::Leaf => "LEAF",
                Self::Nodata => "NODATA",
                Self::UseImageryEpoch => "USE_IMAGERY_EPOCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RICH3D_LEAF" => Some(Self::Rich3dLeaf),
                "RICH3D_NODATA" => Some(Self::Rich3dNodata),
                "LEAF" => Some(Self::Leaf),
                "NODATA" => Some(Self::Nodata),
                "USE_IMAGERY_EPOCH" => Some(Self::UseImageryEpoch),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeData {
    #[prost(double, repeated, tag = "1")]
    pub matrix_globe_from_mesh: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, repeated, tag = "2")]
    pub meshes: ::prost::alloc::vec::Vec<Mesh>,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub copyright_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "4")]
    pub node_key: ::core::option::Option<NodeKey>,
    #[prost(double, repeated, tag = "5")]
    pub kml_bounding_box: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, optional, tag = "6")]
    pub water_mesh: ::core::option::Option<Mesh>,
    #[prost(message, repeated, tag = "7")]
    pub overlay_surface_meshes: ::prost::alloc::vec::Vec<Mesh>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub for_normals: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mesh {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub vertices: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "9")]
    pub vertex_alphas: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub texture_coords: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub indices: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub octant_ranges: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub layer_counts: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "6")]
    pub texture: ::prost::alloc::vec::Vec<Texture>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub texture_coordinates: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, repeated, tag = "10")]
    pub uv_offset_and_scale: ::prost::alloc::vec::Vec<f32>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub layer_and_octant_counts: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "11")]
    pub normals: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "16")]
    pub normals_dev: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "12")]
    pub mesh_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "13")]
    pub skirt_flags: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `Mesh`.
pub mod mesh {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Layer {
        Overground = 0,
        TerrainBelowWater = 1,
        TerrainAboveWater = 2,
        TerrainHidden = 3,
        Water = 4,
        WaterSkirts = 5,
        WaterSkirtsInverted = 6,
        OverlaySurface = 7,
        OverlaySurfaceSkirts = 8,
        NumLayers = 9,
    }
    impl Layer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Overground => "OVERGROUND",
                Self::TerrainBelowWater => "TERRAIN_BELOW_WATER",
                Self::TerrainAboveWater => "TERRAIN_ABOVE_WATER",
                Self::TerrainHidden => "TERRAIN_HIDDEN",
                Self::Water => "WATER",
                Self::WaterSkirts => "WATER_SKIRTS",
                Self::WaterSkirtsInverted => "WATER_SKIRTS_INVERTED",
                Self::OverlaySurface => "OVERLAY_SURFACE",
                Self::OverlaySurfaceSkirts => "OVERLAY_SURFACE_SKIRTS",
                Self::NumLayers => "NUM_LAYERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERGROUND" => Some(Self::Overground),
                "TERRAIN_BELOW_WATER" => Some(Self::TerrainBelowWater),
                "TERRAIN_ABOVE_WATER" => Some(Self::TerrainAboveWater),
                "TERRAIN_HIDDEN" => Some(Self::TerrainHidden),
                "WATER" => Some(Self::Water),
                "WATER_SKIRTS" => Some(Self::WaterSkirts),
                "WATER_SKIRTS_INVERTED" => Some(Self::WaterSkirtsInverted),
                "OVERLAY_SURFACE" => Some(Self::OverlaySurface),
                "OVERLAY_SURFACE_SKIRTS" => Some(Self::OverlaySurfaceSkirts),
                "NUM_LAYERS" => Some(Self::NumLayers),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LayerMask {
        TerrainWithOverground = 7,
        TerrainWithWater = 28,
        TerrainWithoutWater = 14,
    }
    impl LayerMask {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TerrainWithOverground => "TERRAIN_WITH_OVERGROUND",
                Self::TerrainWithWater => "TERRAIN_WITH_WATER",
                Self::TerrainWithoutWater => "TERRAIN_WITHOUT_WATER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERRAIN_WITH_OVERGROUND" => Some(Self::TerrainWithOverground),
                "TERRAIN_WITH_WATER" => Some(Self::TerrainWithWater),
                "TERRAIN_WITHOUT_WATER" => Some(Self::TerrainWithoutWater),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Texture {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "texture::Format", optional, tag = "2")]
    pub format: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3", default = "256")]
    pub width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4", default = "256")]
    pub height: ::core::option::Option<u32>,
    #[prost(enumeration = "texture::ViewDirection", optional, tag = "5")]
    pub view_direction: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub mesh_id: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Texture`.
pub mod texture {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Format {
        Jpg = 1,
        Dxt1 = 2,
        Etc1 = 3,
        Pvrtc2 = 4,
        Pvrtc4 = 5,
        CrnDxt1 = 6,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Jpg => "JPG",
                Self::Dxt1 => "DXT1",
                Self::Etc1 => "ETC1",
                Self::Pvrtc2 => "PVRTC2",
                Self::Pvrtc4 => "PVRTC4",
                Self::CrnDxt1 => "CRN_DXT1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JPG" => Some(Self::Jpg),
                "DXT1" => Some(Self::Dxt1),
                "ETC1" => Some(Self::Etc1),
                "PVRTC2" => Some(Self::Pvrtc2),
                "PVRTC4" => Some(Self::Pvrtc4),
                "CRN_DXT1" => Some(Self::CrnDxt1),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ViewDirection {
        Nadir = 0,
        North45 = 1,
        East45 = 2,
        South45 = 3,
        West45 = 4,
    }
    impl ViewDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Nadir => "NADIR",
                Self::North45 => "NORTH_45",
                Self::East45 => "EAST_45",
                Self::South45 => "SOUTH_45",
                Self::West45 => "WEST_45",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NADIR" => Some(Self::Nadir),
                "NORTH_45" => Some(Self::North45),
                "EAST_45" => Some(Self::East45),
                "SOUTH_45" => Some(Self::South45),
                "WEST_45" => Some(Self::West45),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextureData {
    #[prost(message, optional, tag = "1")]
    pub node_key: ::core::option::Option<NodeKey>,
    #[prost(message, repeated, tag = "2")]
    pub textures: ::prost::alloc::vec::Vec<Texture>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Copyrights {
    #[prost(message, repeated, tag = "1")]
    pub copyrights: ::prost::alloc::vec::Vec<Copyright>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Copyright {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub text_clean: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanetoidMetadata {
    #[prost(message, optional, tag = "1")]
    pub root_node_metadata: ::core::option::Option<NodeMetadata>,
    #[prost(float, optional, tag = "2")]
    pub radius: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub min_terrain_altitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub max_terrain_altitude: ::core::option::Option<f32>,
}
